# Austin Klum
# 2017/11/23
# Takes in user input into an array and prints out the array in sorted order using quicksort.
	.data
array:    .space 80
lblSort:  .asciiz "Sorted: "
lblSpace: .asciiz " "
lblMsg:   .asciiz "sort was called!"
	.text
main:	addi	$v0, $zero, 5		#Get things ready for user input
	syscall
	add	$s2, $zero, $v0	 	#s2 = user inputted length 
	add	$s1, $zero, $zero	# set s1 to i
	la 	$s0, array		#Load first addr of array into s0

startl:	slt 	$t0, $s1, $s2 	 	# length < i ? 1 : 0
	beq 	$t0, $zero,endl 	# if i > input; stop user inputting
	
	#Get input
	sll	$t0, $s1, 2 		#t0 = i * 4
	add	$s4, $s0, $t0 	 	#s4 = arr + i*4
	lw	$s3, 0($s4)	 	#s3 = arr[i]
	addi 	$v0, $zero, 5 	 	#Get things ready for user input
	syscall

	#Add to array
	add 	$s3, $zero, $v0  	#arr[i] = user input
	sw	$s3, 0($s4)	 	#save the new value

	addi	$s1, $s1, 1 	 	#i++
	j startl			#Jump to start of loop

	#get things ready to call quick sort
endl: 	add	$a0, $s0, $zero		#a0 = array sart pos
	add 	$a1, $s2, $zero		#a1 = length
	jal	sort			#call sort
	
	#Loop through and print sorted array
	add 	$s1, $zero, $zero	#i = 0
print:	slt	$t0, $s1, $s2  		#t0 = i < length ? 1 : 0
	beq	$t0, $zero, exit 	#(i < 0) -> exit
	sll	$t0, $s1, 2 	 	# t0 = i * 4
	add	$t0, $s0, $t0 	 	#t0 = arr + i*4
	lw	$s2, 0($t0)		#s2 = arr[i]

	#Load into arguments array[i]
	la	$a0, 0($s2) 		# Load arr[i] into the args
	addi	$v0, $zero, 1		# Tell system we want to print an integer
	syscall
	la	$a0, lblSpace  	 	#Load lblSpace into the args
	addi 	$v0, $zero, 4	 	# Tell system we want to print
	syscall
	
	addi	$s1, $s1, 1 	 	#i++
	j print		
	
exit:	addi	$v0, $zero, 10		# Tell system to exit
	syscall

	# quick_sort 
	# Sorts an int[] array
	# @param arr
	# @param length
sort:   addi	$sp, $sp, -4		#Add to the stack
	sw	$ra, 0($sp)		#store $ra
# -------------------------------------------------------------------------------
	#Get things ready to call the helper
	addi	$a2, $a1, -1		#a2 = length -1
	add 	$a1, $zero, $zero	#a1 = 0
	jal 	help
# -------------------------------------------------------------------------------
	lw	$ra, 0($ra)		#restore $ra
	jr  	$ra

	# quick_sort_helper
	# recursive helper method
	# @param arr
	# @param left
	# @param right
help:   addi 	$sp, $sp, -16		#add to stack
	
	#store ra,s0,left,and right
	sw 	$ra, 12($sp)		#$ra
	sw	$s0,  8($sp)		#index
	sw	$a1,  4($sp)		#left
	sw	$a2,  0($sp)		#right
# -------------------------------------------------------------------------------
	#call partition, Should be safe to call
	jal 	part			
	add 	$s0, $v0, $zero 	#index = partition(arr, left, right)
# -------------------------------------------------------------------------------	
	#restore left, right
	lw 	$a1,  4($sp)
	lw	$a2,  0($sp)		
	#addi	$sp,  $sp, 8		# pop the left and right from stack
	addi	$t0, $s0, -1		#t0 = index - 1
	slt	$t0, $s0, $t0		#t0 = left < index - 1
	beq 	$t0, $zero, else	# !(left < index-1) -> else
	# get things ready for recursion
	addi	$a2, $s0, -1		#a2 = index - 1
	jal 	help
	j 	ret
	
else:	slt	$t0, $s0, $a2		# t0 = index < right
	beq 	$t0, $zero, ret		# !(index < right) -> ret
	add	$a1, $s0, $zero		# a1 = index
	jal	help

ret:	#restore values
	lw 	$ra, 12($sp)		#$ra
	lw	$s0,  8($sp)		#index
	addi	$sp, $sp, 20		#pop stack
	jr 	$ra			#return

part:	# partition
	# does the actual sorting
	# @param arr
	# @param left
	# @param right

	#store s0 = i, s1 = j, s2 = pivot
	addi 	$sp, $sp, -12		#make room	
	sw	$s0, 8($sp)		
	sw	$s1, 4($sp)
	sw 	$s0, 0($sp)

	add	$t0, $a1, $a2	# t0 = left + right
	srl	$t0, $t0, 1	# t0 = (left + right) / 2
	
	sll	$t0, $t0, 2	# ((left + right) / 2) * 4
	add	$t0, $t0, $a0	# arr + ((left + right) / 2) * 4
	lw 	$t9, 0($t0)	# t9 = arr[(left + right) / 2]

	